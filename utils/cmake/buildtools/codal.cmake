add_executable(
    ${device.device}
    ${SOURCE_FILES}
)

if("${INCLUDE_DIRS}" STRGREATER "")
    target_include_directories(${device.device} PUBLIC "${INCLUDE_DIRS}")
endif()

set_target_properties(${device.device} PROPERTIES SUFFIX "" ENABLE_EXPORTS ON)

# link the executable with supporting libraries.
target_link_libraries(
    ${device.device}
    ${CODAL_DEPS}
)

# import toolchain bin generation command
if(${device.generate_bin})
    include(${TOOLCHAIN_FOLDER}/bin-generator.cmake)
endif()

# import toolchain hex generation command
if(${device.generate_hex})
    include(${TOOLCHAIN_FOLDER}/hex-generator.cmake)
endif()

# import toolchain show build size command
if(${device.show_size})
    include(${TOOLCHAIN_FOLDER}/size-info.cmake)
endif()

# post process command hook, depends on the hex file generated by the build system.
if("${device.post_process.command}" STRGREATER "" OR "${device.post_process}" STRGREATER "")
    if("${device.post_process}" STRGREATER "")
        set(POST_PROCESS_COMMAND ${device.post_process})
    else()
        set(POST_PROCESS_COMMAND ${device.post_process.command})
    endif()

    set(POST_PROCESS_DEPENDS "${device.post_process.depends}")

    # replace specific strings in the command, this gives users flexibility, they don't have to manually specify the location of files
    string(REPLACE "<OUTPUT_HEX_LOCATION>" ${PROJECT_SOURCE_DIR}/${CODAL_APP_OUTPUT_DIR}/${device.device}.hex CODAL_POSTPROCESS_COMMAND ${POST_PROCESS_COMMAND})
    string(REPLACE "<OUTPUT_HEX_DESTINATION>" ${PROJECT_SOURCE_DIR}/${CODAL_APP_OUTPUT_DIR} CODAL_POSTPROCESS_COMMAND ${CODAL_POSTPROCESS_COMMAND})
    string(REPLACE "<OUTPUT_HEX_NAME>" ${device.device} CODAL_POSTPROCESS_COMMAND ${CODAL_POSTPROCESS_COMMAND})

    string(REPLACE "<OUTPUT_BIN_LOCATION>" ${PROJECT_SOURCE_DIR}/${CODAL_APP_OUTPUT_DIR}/${device.device}.bin CODAL_POSTPROCESS_COMMAND ${CODAL_POSTPROCESS_COMMAND})
    string(REPLACE "<OUTPUT_BIN_DESTINATION>" ${PROJECT_SOURCE_DIR}/${CODAL_APP_OUTPUT_DIR} CODAL_POSTPROCESS_COMMAND ${CODAL_POSTPROCESS_COMMAND})
    string(REPLACE "<OUTPUT_BIN_NAME>" ${device.device}.bin CODAL_POSTPROCESS_COMMAND ${CODAL_POSTPROCESS_COMMAND})

    string(REPLACE "<OUTPUT_ELF_LOCATION>" ${PROJECT_SOURCE_DIR}/build/${device.device} CODAL_POSTPROCESS_COMMAND ${CODAL_POSTPROCESS_COMMAND})
    string(REPLACE "<OUTPUT_ELF_DESTINATION>" ${PROJECT_SOURCE_DIR}/${CODAL_APP_OUTPUT_DIR} CODAL_POSTPROCESS_COMMAND ${CODAL_POSTPROCESS_COMMAND})
    string(REPLACE "<OUTPUT_ELF_NAME>" ${device.device} CODAL_POSTPROCESS_COMMAND ${CODAL_POSTPROCESS_COMMAND})

    string(REPLACE "<CODAL_APP_OUTPUT_DIR>" ${PROJECT_SOURCE_DIR}/${CODAL_APP_OUTPUT_DIR} CODAL_POSTPROCESS_COMMAND ${CODAL_POSTPROCESS_COMMAND})

    # convert to a command
    separate_arguments(FINAL_COMMAND UNIX_COMMAND ${CODAL_POSTPROCESS_COMMAND})

    # execute
    if(POST_PROCESS_DEPENDS STREQUAL "ELF")
        add_custom_command(
            TARGET ${device.device}
            COMMAND ${FINAL_COMMAND}
            DEPENDS ${device.device}
            WORKING_DIRECTORY "${PROJECT_SOURCE_DIR}"
            COMMENT "Executing post process command"
        )
    elseif(POST_PROCESS_DEPENDS STREQUAL "HEX")
        add_custom_command(
            TARGET ${device.device}_hex
            COMMAND ${FINAL_COMMAND}
            DEPENDS ${device.device}
            WORKING_DIRECTORY "${PROJECT_SOURCE_DIR}"
            COMMENT "Executing post process command"
        )
    else()
        # by default post process should depend on hex
        add_custom_command(
            TARGET ${device.device}_bin
            COMMAND ${FINAL_COMMAND}
            DEPENDS ${device.device}
            WORKING_DIRECTORY "${PROJECT_SOURCE_DIR}"
            COMMENT "Executing post process command"
        )
    endif()
endif()

# Generate c_cpp_properties.json for VS Code IntelliSense
# Collect all include directories from the target and its dependencies
set(ALL_INCLUDE_DIRS "")

# Add application include directories
if(INCLUDE_DIRS)
    list(APPEND ALL_INCLUDE_DIRS ${INCLUDE_DIRS})
endif()

# Add libraries root directory
list(APPEND ALL_INCLUDE_DIRS "${PROJECT_SOURCE_DIR}/${LIB_DEST}")

# Add platform includes
list(APPEND ALL_INCLUDE_DIRS "${PLATFORM_INCLUDES_PATH}")

# Collect include directories from all CODAL dependencies
foreach(dep ${CODAL_DEPS})
    get_target_property(dep_includes ${dep} INTERFACE_INCLUDE_DIRECTORIES)

    if(dep_includes)
        list(APPEND ALL_INCLUDE_DIRS ${dep_includes})
    endif()
endforeach()

# Remove duplicates
list(REMOVE_DUPLICATES ALL_INCLUDE_DIRS)

# Convert the include paths to JSON array format
set(INCLUDE_PATHS_JSON "")

foreach(inc_dir ${ALL_INCLUDE_DIRS})
    # Make paths absolute
    get_filename_component(abs_path "${inc_dir}" ABSOLUTE)

    if(INCLUDE_PATHS_JSON)
        set(INCLUDE_PATHS_JSON "${INCLUDE_PATHS_JSON},\n                \"${abs_path}\"")
    else()
        set(INCLUDE_PATHS_JSON "\"${abs_path}\"")
    endif()
endforeach()

# Build defines list from FINAL_FIELDS and FINAL_VALUES
set(DEFINES_JSON "")

if(FINAL_FIELDS AND FINAL_VALUES)
    list(LENGTH FINAL_FIELDS num_defines)
    math(EXPR last_index "${num_defines} - 1")

    foreach(index RANGE ${last_index})
        list(GET FINAL_FIELDS ${index} define_key)
        list(GET FINAL_VALUES ${index} define_value)

        # Escape double quotes in the value
        string(REPLACE "\"" "\\\"" define_value_escaped "${define_value}")

        # Format as KEY=VALUE or just KEY if value is empty (but not if it's "0")
        if(NOT define_value_escaped STREQUAL "")
            set(define_entry "${define_key}=${define_value_escaped}")
        else()
            set(define_entry "${define_key}")
        endif()

        if(DEFINES_JSON)
            set(DEFINES_JSON "${DEFINES_JSON},\n                \"${define_entry}\"")
        else()
            set(DEFINES_JSON "\"${define_entry}\"")
        endif()
    endforeach()
endif()

# Parse device.definitions for additional -D flags
if("${device.definitions}" STRGREATER "")
    # Split by spaces and extract -D flags
    string(REPLACE " " ";" definitions_list "${device.definitions}")

    foreach(def_flag ${definitions_list})
        # Check if this is a -D flag
        if(def_flag MATCHES "^-D(.+)")
            # Extract the definition (everything after -D)
            string(REGEX REPLACE "^-D(.+)" "\\1" def_content "${def_flag}")

            # Escape double quotes
            string(REPLACE "\"" "\\\"" def_content "${def_content}")

            if(DEFINES_JSON)
                set(DEFINES_JSON "${DEFINES_JSON},\n                \"${def_content}\"")
            else()
                set(DEFINES_JSON "\"${def_content}\"")
            endif()
        endif()
    endforeach()
endif()

# Determine compiler path
if(CMAKE_C_COMPILER)
    set(COMPILER_PATH "${CMAKE_C_COMPILER}")
else()
    set(COMPILER_PATH "")
endif()

# Determine IntelliSense mode based on toolchain
if(TOOLCHAIN MATCHES "ARM_GCC" OR CMAKE_C_COMPILER MATCHES "arm-none-eabi")
    set(INTELLISENSE_MODE "linux-gcc-arm")
elseif(CMAKE_C_COMPILER MATCHES "gcc")
    set(INTELLISENSE_MODE "gcc-x64")
elseif(CMAKE_C_COMPILER MATCHES "clang")
    set(INTELLISENSE_MODE "clang-x64")
else()
    set(INTELLISENSE_MODE "gcc-arm")
endif()

# Create the c_cpp_properties.json content
set(CPP_PROPERTIES_CONTENT "{
    \"configurations\": [
        {
            \"name\": \"CODAL\",
            \"includePath\": [
                ${INCLUDE_PATHS_JSON}
            ],
            \"defines\": [
                ${DEFINES_JSON}
            ],
            \"compilerPath\": \"${COMPILER_PATH}\",
            \"cStandard\": \"c11\",
            \"cppStandard\": \"c++11\",
            \"intelliSenseMode\": \"${INTELLISENSE_MODE}\"
        }
    ],
    \"version\": 4
}")

# Ensure .vscode directory exists
file(MAKE_DIRECTORY "${PROJECT_SOURCE_DIR}/.vscode")

# Write the c_cpp_properties.json file
file(WRITE "${PROJECT_SOURCE_DIR}/.vscode/c_cpp_properties.json" "${CPP_PROPERTIES_CONTENT}")

message("${BoldGreen}Generated .vscode/c_cpp_properties.json for IntelliSense${ColourReset}")